/***

    ./src/lib/pdb.c 

    Protein Motion TK (pmtk) - A library and several tools to estimate protein motions from varying input
    Copyright (C) 2009-2014  Benjamin Falkner

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.


*/





#ifdef __cplusplus
extern "C"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "pdb.h"

#ifndef ALLOCPAGESIZE
#define ALLOCPAGESIZE 1024
#endif

#define STRINGIFY(x) #x

int getType(const char* name)
{
	char *p=0,*e=(char*)name;
	while(*e){
		if(*e=='.')
			p=e;
		e++;
	}
	if(!p && e-p!=5)
		return 0;

	if((p[1]=='p' || p[1]=='P') &&
	   (p[2]=='d' || p[2]=='D') &&
	   (p[3]=='b' || p[3]=='B')){
		return PM_ATOM_FILE_PDB;
	}
	else if(
	   (p[1]=='x' || p[1]=='X') &&
	   (p[2]=='t' || p[2]=='T') &&
	   (p[3]=='c' || p[3]=='C')){
	    return PM_ATOM_FILE_XDR;
	}
	return 0;
}

static void fail(char* msg)
{
	fprintf(stderr,"ERROR: %s\n",msg); 
	exit(1);
}


static inline void _readLineS(char *line, float coords[])
{
	//read coords
	line[54]='\0';
    coords[2]=atof(&line[46]);
	line[46]='\0';
	coords[1]=atof(&line[38]);
	line[38]='\0';
	coords[0]=atof(&line[30]);
}

static inline void _readLine(char *line, PMAtomDesc *info, float coords[])
{
	//read info
	register char *s = (char*)info;
	s[0]=line[0];
	memcpy(&s[1],&line[6],21);
	//read coords
	line[54]='\0';
    coords[2]=atof(&line[46]);
	line[46]='\0';
	coords[1]=atof(&line[38]);
	line[38]='\0';
	coords[0]=atof(&line[30]);
}





float *pmFReadPDBFrameFull(FILE* stream,PMAtomDesc** atominfo,size_t *atoms)
{
	size_t i=0;
	char linebuffer[128];

	float *coords=0, *c;
	PMAtomDesc *info=0, *a;

	size_t alloc = ALLOCPAGESIZE;

	//check if size is known
	if(*atoms)
		alloc = *atoms;

	while(fgets(linebuffer,128,stream)){
	        //fprintf(stderr,"%i[%i]\n",i,(i%alloc));
		//only atom lines
		if(!strncmp(linebuffer,"ATOM",4) || !strncmp(linebuffer,"HETATM",6)){
			//test line
	        if(strlen(linebuffer)<54)break; // underfull line

	        //allocate more memory
	        if(!(i%alloc)){
		        //fprintf(stderr,">>>>>>%p<<<<<<<\n",coords);
	        	c = (float*)realloc(coords,(i/alloc+1)*alloc*3*sizeof(float));
			if(!c) fail(__FILE__"[" STRINGIFY(__LINE__) "]: failed to allocate coordinates array");	
			else coords = (float*) c;
	        	a = (PMAtomDesc*) realloc(info,(i/alloc+1)*alloc*sizeof(PMAtomDesc));
			if(!a) fail(__FILE__"[" STRINGIFY(__LINE__) "]: failed to allocate atomic info array");	
			else info = (PMAtomDesc *) a;

			c=&coords[i*3];
			a=&info[i];
		        //fprintf(stderr,">>>>>>%p<<<<<<<\n",coords);
	        }


	        //reading
	        _readLine(linebuffer,a++,c);
	        c+=3;
	        i++;
	    }
		//any line with end stops reading ENDMDL and END
	    else if(!strncmp(linebuffer,"END",3))
	    	break;
	}
	if (*atoms) { //test if size matches
		if(*atoms != i) {
			free(info);
			free(coords);
			return 0;
		}
	}
	else {
		*atoms=i;
	    coords = (float*)   realloc(coords,i*3*sizeof(float));
	    info   = (PMAtomDesc*) realloc(info,i*sizeof(PMAtomDesc));
	}
	*atominfo = info;
	return coords;
}

float *pmFReadPDBFramePlain(FILE* stream,size_t *atoms)
{
	size_t i=0;
	char linebuffer[128];
	float *coords,*c;

	coords = (float*)malloc(*atoms*3*sizeof(float));
	if(!coords) fail(__FILE__"[" STRINGIFY(__LINE__) "]: failed to allocate coordinates array");	
	c=coords;

	while(fgets(linebuffer,128,stream)){
		if(i>*atoms){
			free(coords);
			return 0;
		}
		//only atom lines
		if(!strncmp(linebuffer,"ATOM",4) || !strncmp(linebuffer,"HETATM",6)){
			//test line
	        if(strlen(linebuffer)<54)break; // underfull line


	        //reading
	        _readLineS(linebuffer,c);
	        c+=3;
	        i++;
	    }
		//any line with end stops reading ENDMDL and END
	    else if(!strncmp(linebuffer,"END",3))
	    	break;
	}

	if(*atoms != i) { // if not enough atoms
		free(coords);
		return 0;
	}
	return coords;
}


int pmFWriteFramesPDB(FILE* f, PMAtomDesc* info, float **data,size_t models,size_t atoms)
{
	float *datap,x,y,z;
	size_t i,j;
	char *c;

	// Header
	fprintf(f,"REMARK PDB OUTPUT\n"
	    	  "REMARK PDB GENERATED BY PMTK\n"
	          "REMARK PDB FRAMES: %zu\n"
	          "REMARK PDB ATOMS PER FRAME: %zu\n",models,atoms);

	// Data output
    if(info){
    	for(i=0;i<models;i++){
	      fprintf(f,"MODEL   %4zu\n",i);
	      datap=*data;
	      for(j=0;j<atoms;j++){
	        x=*datap++;
	        y=*datap++;
	        z=*datap++;
	        c = (char*) &(*info++);
	        fprintf(f,"%6s%.21s   %8.3f%8.3f%8.3f%6.2f%6.2f\n",
	          (*c=='H')?"HETATM":"ATOM  ",
	          &c[1],
	          x,
	          y,
	          z,
	          0.0,
	          0.0);
	      }
	      data++;
	      fprintf(f,"ENDMDL\n");
	}
	fprintf(f,"END\n");
    }
    else{
    	for(i=0;i<models;i++){
    		fprintf(f,"MODEL   %4zu\n",i);
    		datap=*data;
    		for(j=0;j<atoms;j++){
    		        x=*datap++;
    		        y=*datap++;
    		        z=*datap++;
    		        c = (char*) &(*info++);
    		        fprintf(f,"ATOM  %6lu CA               %8.3f%8.3f%8.3f%6.2f%6.2f\n",
    		          j,
    		          x,
    		          y,
    		          z,
    		          0.0,
    		          0.0);
    		}
    		fprintf(f,"ENDMDL\n");
    		data++;
    	}
    	fprintf(f,"END\n");
    }
	fclose(f);
	return 0;
}










